{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"allowAutoHeight\", \"children\", \"defaultHeight\", \"estimatedItemSize\", \"height\", \"onScroll\", \"overscanCount\", \"scrollOffset\", \"scrollToAlignment\", \"scrollToIndex\", \"useAverageAutoHeightEstimation\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useState, useEffect } from 'react';\nimport VirtualList from '@segment/react-tiny-virtual-list';\nimport debounce from 'lodash.debounce';\nimport PropTypes from 'prop-types';\nimport { useForceUpdate } from '../../hooks';\nimport { Pane } from '../../layers';\nvar TableVirtualBody = /*#__PURE__*/memo(function TableVirtualBody(props) {\n  var _props$allowAutoHeigh = props.allowAutoHeight,\n      allowAutoHeight = _props$allowAutoHeigh === void 0 ? false : _props$allowAutoHeigh,\n      inputChildren = props.children,\n      _props$defaultHeight = props.defaultHeight,\n      defaultHeight = _props$defaultHeight === void 0 ? 48 : _props$defaultHeight,\n      estimatedItemSize = props.estimatedItemSize,\n      paneHeight = props.height,\n      onScroll = props.onScroll,\n      _props$overscanCount = props.overscanCount,\n      overscanCount = _props$overscanCount === void 0 ? 5 : _props$overscanCount,\n      scrollOffset = props.scrollOffset,\n      scrollToAlignment = props.scrollToAlignment,\n      scrollToIndex = props.scrollToIndex,\n      _props$useAverageAuto = props.useAverageAutoHeightEstimation,\n      useAverageAutoHeightEstimation = _props$useAverageAuto === void 0 ? true : _props$useAverageAuto,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var forceUpdate = useForceUpdate();\n  var autoHeights = [];\n  var autoHeightRefs = [];\n  var averageAutoHeight = defaultHeight;\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      paneRef = _useState2[0],\n      setPaneRef = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isIntegerHeight = _useState4[0],\n      setIsIntegerHeight = _useState4[1];\n\n  var _useState5 = useState(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      calculatedHeight = _useState6[0],\n      setCalculatedHeight = _useState6[1];\n\n  var updateOnResize = function updateOnResize() {\n    autoHeights = [];\n    autoHeightRefs = [];\n    averageAutoHeight = defaultHeight; // Simply return when we now the height of the pane is fixed.\n\n    if (isIntegerHeight) return; // Return if we are in a weird edge case in which the ref is no longer valid.\n\n    if (paneRef && paneRef instanceof Node) {\n      var tempCalculatedHeight = paneRef.offsetHeight;\n\n      if (tempCalculatedHeight > 0) {\n        // Save the calculated height which is needed for the VirtualList.\n        setCalculatedHeight(tempCalculatedHeight); // Prevent updateOnResize being called recursively when there is a valid height.\n\n        return;\n      }\n    } // When height is still 0 (or paneRef is not valid) try recursively until success.\n\n\n    requestAnimationFrame(function () {\n      updateOnResize();\n    });\n  };\n\n  var onResize = debounce(updateOnResize, 200);\n  useEffect(function () {\n    if (props.height !== calculatedHeight) {\n      setIsIntegerHeight(Number.isInteger(props.height));\n    }\n  }, [props.height]);\n  useEffect(function () {\n    if (paneRef && paneRef instanceof Node) {\n      updateOnResize();\n    }\n  }, [paneRef]); // Mirrors functionality of componentDidMount and componentWillUnmount.\n  // By passing an empty array, will only run on first render, the function returned\n  // will be called on component unmount\n\n  useEffect(function () {\n    updateOnResize();\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      window.removeEventListener('resize', onResize);\n    };\n  }, []);\n  /**\n   * This function will process all items that have height=\"auto\" set.\n   * It will loop through all refs and get calculate the height.\n   */\n\n  var processAutoHeights = function processAutoHeights() {\n    var isUpdated = false; // This will determine the averageAutoHeight.\n\n    var total = 0;\n    var totalAmount = 0; // Loop through all of the refs that have height=\"auto\".\n\n    autoHeightRefs.forEach(function (ref, index) {\n      // If the height is already calculated, skip it,\n      // but calculate the height for the total.\n      if (autoHeights[index]) {\n        total += autoHeights[index];\n        totalAmount += 1;\n        return;\n      } // Make sure the ref has a child\n\n\n      if (ref && ref.childNodes && ref.childNodes[0] && Number.isInteger(ref.childNodes[0].offsetHeight)) {\n        var height = ref.childNodes[0].offsetHeight; // Add to the total to calculate the averageAutoHeight.\n\n        total += height;\n        totalAmount += 1; // Cache the height.\n\n        autoHeights[index] = height; // Set the update flag to true.\n\n        isUpdated = true;\n      }\n    }); // Save the average height.\n\n    averageAutoHeight = total / totalAmount; // There are some new heights detected that had previously not been calculated.\n    // Call forceUpdate to make sure the virtual list renders again.\n\n    if (isUpdated) forceUpdate();\n  };\n\n  var onVirtualHelperRef = function onVirtualHelperRef(index, ref) {\n    autoHeightRefs[index] = ref;\n    requestAnimationFrame(function () {\n      processAutoHeights();\n    });\n  };\n\n  var getItemSize = function getItemSize(children) {\n    // Prefer to return a array of all heights.\n    if (!allowAutoHeight) {\n      return children.map(function (child) {\n        if (! /*#__PURE__*/React.isValidElement(child)) return defaultHeight;\n        var height = child.props.height;\n\n        if (Number.isInteger(height)) {\n          return height;\n        }\n\n        return defaultHeight;\n      });\n    } // If allowAutoHeight is true, return a function instead.\n\n\n    var itemSizeFn = function itemSizeFn(index) {\n      if (! /*#__PURE__*/React.isValidElement(children[index])) return defaultHeight;\n      var height = children[index].props.height; // When the height is number simply, simply return it.\n\n      if (Number.isInteger(height)) {\n        return height;\n      } // When allowAutoHeight is set and  the height is set to \"auto\"...\n\n\n      if (allowAutoHeight && children[index].props.height === 'auto') {\n        // ... and the height is calculated, return the calculated height.\n        if (autoHeights[index]) return autoHeights[index]; // ... if the height is not yet calculated, return the averge\n\n        if (useAverageAutoHeightEstimation) return averageAutoHeight;\n      } // Return the default height.\n\n\n      return defaultHeight;\n    };\n\n    return itemSizeFn;\n  }; // Children always needs to be an array.\n\n\n  var children = Array.isArray(inputChildren) ? inputChildren : React.Children.toArray(inputChildren);\n  var itemSize = getItemSize(children);\n  return /*#__PURE__*/React.createElement(Pane, _extends({\n    \"data-evergreen-table-body\": true,\n    ref: setPaneRef,\n    height: paneHeight,\n    flex: \"1\",\n    overflow: \"hidden\"\n  }, rest), /*#__PURE__*/React.createElement(VirtualList, {\n    height: isIntegerHeight ? paneHeight : calculatedHeight,\n    width: \"100%\",\n    estimatedItemSize: allowAutoHeight && useAverageAutoHeightEstimation ? averageAutoHeight : estimatedItemSize || null,\n    itemSize: itemSize,\n    overscanCount: overscanCount,\n    itemCount: React.Children.count(children),\n    scrollToIndex: scrollToIndex,\n    scrollOffset: scrollOffset,\n    scrollToAlignment: scrollToAlignment,\n    onScroll: onScroll,\n    renderItem: function renderItem(_ref) {\n      var index = _ref.index,\n          style = _ref.style;\n      var child = children[index];\n      var key = child.key || index;\n      var props = {\n        key: key,\n        style: style\n      }; // If some children are strings by accident, support this gracefully.\n\n      if (! /*#__PURE__*/React.isValidElement(child)) {\n        if (typeof child === 'string') {\n          return /*#__PURE__*/React.createElement(\"div\", props, child);\n        }\n\n        return /*#__PURE__*/React.createElement(\"div\", props, \"\\xA0\");\n      } // When allowing height=\"auto\" for rows, and a auto height item is\n      // rendered for the first time...\n\n\n      if (allowAutoHeight && /*#__PURE__*/React.isValidElement(child) && child.props.height === 'auto' && // ... and only when the height is not already been calculated.\n      !autoHeights[index]) {\n        // ... render the item in a helper div, the ref is used to calculate\n        // the height of its children.\n        return /*#__PURE__*/React.createElement(\"div\", _extends({\n          ref: function ref(_ref2) {\n            return onVirtualHelperRef(index, _ref2);\n          },\n          \"data-virtual-index\": index\n        }, props, {\n          style: _objectSpread({\n            opacity: 0\n          }, props.style)\n        }), child);\n      } // When allowAutoHeight is false, or when the height is known.\n      // Simply render the item.\n\n\n      return /*#__PURE__*/React.cloneElement(child, props);\n    }\n  }));\n});\nTableVirtualBody.propTypes = _objectSpread(_objectSpread({}, Pane.propTypes), {}, {\n  /**\n   * Children needs to be an array of a single node.\n   */\n  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),\n\n  /**\n   * Default height of each row.\n   * 48 is the default height of a TableRow.\n   */\n  defaultHeight: PropTypes.number,\n\n  /**\n   * When true, support `height=\"auto\"` on children being rendered.\n   * This is somewhat of an expirmental feature.\n   */\n  allowAutoHeight: PropTypes.bool,\n\n  /**\n   * The overscanCount property passed to react-tiny-virtual-list.\n   */\n  overscanCount: PropTypes.number,\n\n  /**\n   * When passed, this is used as the `estimatedItemSize` in react-tiny-virtual-list.\n   * Only when `allowAutoHeight` and`useAverageAutoHeightEstimation` are false.\n   */\n  estimatedItemSize: PropTypes.number,\n\n  /**\n   * When allowAutoHeight is true and this prop is true, the estimated height\n   * will be computed based on the average height of auto height rows.\n   */\n  useAverageAutoHeightEstimation: PropTypes.bool,\n\n  /**\n   * The scrollToIndex property passed to react-tiny-virtual-list\n   */\n  scrollToIndex: PropTypes.number,\n\n  /**\n   * The scrollOffset property passed to react-tiny-virtual-list\n   */\n  scrollOffset: PropTypes.number,\n\n  /**\n   * The scrollToAlignment property passed to react-tiny-virtual-list\n   */\n  scrollToAlignment: PropTypes.oneOf(['start', 'center', 'end', 'auto']),\n\n  /**\n   * The onScroll callback passed to react-tiny-virtual-list\n   */\n  onScroll: PropTypes.func\n});\nexport default TableVirtualBody;","map":null,"metadata":{},"sourceType":"module"}