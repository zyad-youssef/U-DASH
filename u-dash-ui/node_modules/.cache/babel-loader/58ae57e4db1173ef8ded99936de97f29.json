{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar _excluded = [\"children\", \"size\", \"selectMenuProps\", \"disabled\", \"placeholder\", \"isSelectable\", \"textProps\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useState, useEffect, useCallback, useMemo } from 'react';\nimport debounce from 'lodash.debounce';\nimport PropTypes from 'prop-types';\nimport { CaretDownIcon } from '../../icons';\nimport { SelectMenu } from '../../select-menu';\nimport TableCell from './TableCell';\nimport TextTableCell from './TextTableCell';\nvar MIN_SELECT_MENU_WIDTH = 240;\nvar emptyProps = {};\nvar SelectMenuCell = /*#__PURE__*/memo(function SelectMenuCell(props) {\n  var _useState = useState(MIN_SELECT_MENU_WIDTH),\n      _useState2 = _slicedToArray(_useState, 2),\n      targetWidth = _useState2[0],\n      setTargetWidth = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      shouldClickToggle = _useState4[0],\n      setShouldClickToggle = _useState4[1];\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      isFocused = _useState6[0],\n      setIsFocused = _useState6[1];\n\n  var _useState7 = useState(),\n      _useState8 = _slicedToArray(_useState7, 2),\n      mainRef = _useState8[0],\n      setMainRef = _useState8[1];\n\n  var children = props.children,\n      _props$size = props.size,\n      size = _props$size === void 0 ? 300 : _props$size,\n      selectMenuProps = props.selectMenuProps,\n      disabled = props.disabled,\n      placeholder = props.placeholder,\n      _props$isSelectable = props.isSelectable,\n      isSelectable = _props$isSelectable === void 0 ? true : _props$isSelectable,\n      _props$textProps = props.textProps,\n      textProps = _props$textProps === void 0 ? emptyProps : _props$textProps,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var updateOnResize = function updateOnResize() {\n    if (!mainRef) return;\n    var mainRefWidth = mainRef.offsetWidth;\n    setTargetWidth(Math.max(MIN_SELECT_MENU_WIDTH, mainRefWidth));\n  };\n\n  var onResize = debounce(updateOnResize, 200);\n  useEffect(function () {\n    updateOnResize();\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      window.removeEventListener('resize', onResize);\n    };\n  }, []);\n\n  var onMainRef = function onMainRef(getRef, ref) {\n    setMainRef(ref);\n    getRef(ref);\n  }; // TODO consider `useClickable`\n\n\n  var handleKeyDown = function handleKeyDown(toggle, isShown, e) {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (!isShown && isSelectable && !disabled) {\n        toggle();\n      }\n    }\n  };\n\n  var handleDoubleClick = function handleDoubleClick(toggle, isShown) {\n    if (!isShown && isSelectable && !disabled) {\n      toggle();\n    }\n  };\n\n  var handleClick = function handleClick(toggle, isShown) {\n    if (!shouldClickToggle && !isShown) {\n      setShouldClickToggle(true);\n      return;\n    }\n\n    if (isSelectable && !disabled) {\n      toggle();\n      setShouldClickToggle(true);\n    }\n  };\n\n  var handleFocus = useCallback(function () {\n    setIsFocused(true);\n  }, []);\n  var handleBlur = useCallback(function () {\n    setShouldClickToggle(false);\n    setIsFocused(false);\n  }, []);\n  var cursor = 'default';\n\n  if (disabled) {\n    cursor = 'not-allowed';\n  } else if (isSelectable) {\n    if (isFocused) {\n      cursor = 'pointer';\n    } else {\n      cursor = 'default';\n    }\n  } else {\n    cursor = 'text';\n  }\n\n  var lessOpacity = useMemo(function () {\n    return disabled || !children && placeholder;\n  }, [disabled, children, placeholder]);\n  var mergedTextProps = useMemo(function () {\n    return _objectSpread({\n      size: size,\n      opacity: lessOpacity ? 0.5 : 1\n    }, textProps);\n  }, [lessOpacity, size, textProps]);\n  return /*#__PURE__*/React.createElement(SelectMenu, _extends({\n    width: targetWidth\n  }, selectMenuProps), function (_ref) {\n    var getRef = _ref.getRef,\n        isShown = _ref.isShown,\n        toggle = _ref.toggle;\n    return /*#__PURE__*/React.createElement(TextTableCell, _extends({\n      ref: onMainRef.bind(null, getRef),\n      onClick: handleClick.bind(null, toggle, isShown),\n      onFocus: handleFocus,\n      onBlur: handleBlur,\n      isSelectable: isSelectable && !disabled,\n      rightView: isSelectable ? /*#__PURE__*/React.createElement(CaretDownIcon, {\n        color: \"muted\"\n      }) : null,\n      \"aria-haspopup\": true,\n      \"aria-expanded\": isShown,\n      cursor: isShown ? 'pointer' : cursor,\n      textProps: mergedTextProps,\n      onKeyDown: handleKeyDown.bind(null, toggle, isShown),\n      onDoubleClick: handleDoubleClick.bind(null, toggle, isShown)\n    }, rest), children || placeholder);\n  });\n});\nSelectMenuCell.propTypes = _objectSpread(_objectSpread({}, TableCell.propTypes), {}, {\n  /*\n   * Makes the TableCell focusable.\n   * Will add tabIndex={-1 || this.props.tabIndex}.\n   */\n  isSelectable: PropTypes.bool,\n\n  /**\n   * When true, the cell can't be edited.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Optional placeholder when children is falsy.\n   */\n  placeholder: PropTypes.node,\n\n  /**\n   * The size used for the TextTableCell and Textarea.\n   */\n  size: PropTypes.oneOf([300, 400]),\n  selectMenuProps: PropTypes.object\n});\nexport default SelectMenuCell;","map":null,"metadata":{},"sourceType":"module"}