{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"defaultValue\", \"disabled\", \"height\", \"name\", \"onChange\", \"options\", \"size\", \"value\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, forwardRef, useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { spacing, position, layout, dimensions } from 'ui-box';\nimport { Button } from '../../buttons';\nimport { Group } from '../../group';\nimport { useId } from '../../hooks';\nimport safeInvoke from '../../lib/safe-invoke';\nimport warning from '../../lib/warning';\n\nfunction isControlled(value) {\n  return typeof value !== 'undefined' && value !== null;\n}\n\nvar SegmentedControl = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function SegmentedControl(props, ref) {\n  var defaultValue = props.defaultValue,\n      disabled = props.disabled,\n      height = props.height,\n      name = props.name,\n      onChange = props.onChange,\n      options = props.options,\n      size = props.size,\n      value = props.value,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var groupName = useId('SegmentedControl');\n\n  if (process.env.NODE_ENV !== 'production') {\n    warning(true, '<SegmentedControl> is deprecated and will be removed in the next major verison of Evergreen. Prefer Tabs for navigational elements, or form components / button groups for other use cases.');\n  }\n\n  var getDefaultValue = function getDefaultValue() {\n    if (isControlled(value)) {\n      return value;\n    }\n\n    return typeof defaultValue !== 'undefined' && defaultValue !== null ? defaultValue : options[0].value;\n  };\n\n  var _useState = useState(getDefaultValue()),\n      _useState2 = _slicedToArray(_useState, 2),\n      activeValue = _useState2[0],\n      setActiveValue = _useState2[1];\n\n  useEffect(function () {\n    if (isControlled(value)) {\n      setActiveValue(value);\n    }\n  }, [value]);\n  var handleChange = useCallback(function (event) {\n    event.preventDefault();\n    var newValue = event.target.value; // Save a render cycle when it's a controlled input\n\n    if (!isControlled(value)) {\n      setActiveValue(newValue);\n    }\n\n    safeInvoke(onChange, newValue);\n  }, [value, onChange]);\n  return /*#__PURE__*/React.createElement(Group, _extends({\n    ref: ref,\n    display: \"flex\"\n  }, rest), options.map(function (option, index) {\n    return /*#__PURE__*/React.createElement(Button, {\n      key: option.value,\n      id: groupName + index,\n      name: name || groupName,\n      value: String(option.value),\n      disabled: disabled,\n      size: size,\n      height: height,\n      isActive: activeValue === String(option.value),\n      onClick: handleChange,\n      flex: \"1\"\n    }, option.label);\n  }));\n}));\nSegmentedControl.propTypes = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, spacing.propTypes), position.propTypes), layout.propTypes), dimensions.propTypes), {}, {\n  /**\n   * The options for the radios of the Segmented Control.\n   */\n  options: PropTypes.arrayOf(PropTypes.shape({\n    label: PropTypes.node.isRequired,\n    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]).isRequired\n  })).isRequired,\n\n  /**\n   * The current value of the Segmented Control when controlled.\n   */\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]),\n\n  /**\n   * The default value of the Segmented Control when uncontrolled.\n   */\n  defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]),\n\n  /**\n   * Function called when the value changes.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * The name of the radio group.\n   */\n  name: PropTypes.string,\n\n  /**\n   * The size of the Segmented Control.\n   */\n  size: PropTypes.oneOf(['small', 'medium', 'large']),\n\n  /**\n   * When true, the Segmented Control is disabled.\n   */\n  disabled: PropTypes.bool\n});\nexport default SegmentedControl;","map":null,"metadata":{},"sourceType":"module"}