{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport isEmpty from 'lodash.isempty';\nimport uniqBy from 'lodash.uniqby';\nimport FileRejectionReason from '../../../constants/src/FileRejectionReason';\nimport hasValue from '../../../lib/has-value';\nimport { getAcceptedTypesMessage, getFileSizeMessage, getMaxFilesMessage } from './messages';\n/**\n * @typedef {object} FileRejection\n * @property {File} file\n * @property {string} message Informative message to display to the user for why the file was rejected\n * @property {string} reason Error code/enum to denote why the file was rejected\n */\n\n/**\n * Returns a list of objects containing rejected files and why they were rejected based on the provided options\n * @param {File[]} files\n * @param {import('./split-files').SplitFilesOptions | undefined} options\n * @returns {FileRejection[]}\n */\n\nvar getFileRejections = function getFileRejections(files, options) {\n  if (options == null || isEmpty(files)) {\n    return [];\n  }\n\n  var acceptedMimeTypes = options.acceptedMimeTypes,\n      currentCount = options.currentFileCount,\n      maxFiles = options.maxFiles,\n      maxSizeInBytes = options.maxSizeInBytes;\n  var typeRejections = files.map(function (file) {\n    if (isEmpty(acceptedMimeTypes) || acceptedMimeTypes !== null && acceptedMimeTypes !== void 0 && acceptedMimeTypes.some(function (type) {\n      return file.type === type;\n    })) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.InvalidFileType,\n      message: \"This file is not an accepted format. \".concat(getAcceptedTypesMessage(acceptedMimeTypes))\n    };\n  });\n  var sizeRejections = files.map(function (file) {\n    if (maxSizeInBytes == null || maxSizeInBytes === 0 || file.size <= maxSizeInBytes) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.FileTooLarge,\n      message: \"This file is too big. \".concat(getFileSizeMessage(maxSizeInBytes))\n    };\n  });\n  var countRejections = files.map(function (file, index) {\n    if (maxFiles == null) {\n      return;\n    }\n\n    var fileNumber = index + 1;\n\n    if ((currentCount !== null && currentCount !== void 0 ? currentCount : 0) + fileNumber <= maxFiles) {\n      return;\n    }\n\n    return {\n      file: file,\n      reason: FileRejectionReason.OverFileLimit,\n      message: getMaxFilesMessage(maxFiles)\n    };\n  }); // Type rejections are arguably more important than size rejections, so those will take priority\n\n  var fileRejections = [].concat(_toConsumableArray(typeRejections), _toConsumableArray(sizeRejections), _toConsumableArray(countRejections)).filter(hasValue);\n  return uniqBy(fileRejections, function (rejection) {\n    return rejection.file;\n  });\n};\n\nexport default getFileRejections;","map":null,"metadata":{},"sourceType":"module"}