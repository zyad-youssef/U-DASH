{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nvar _excluded = [\"children\", \"itemSize\", \"position\", \"renderItem\", \"isFilterDisabled\", \"itemsFilter\", \"itemToString\", \"popoverMaxHeight\", \"popoverMinWidth\", \"allowOtherValues\"],\n    _excluded2 = [\"getItemProps\", \"getMenuProps\", \"getRootProps\", \"highlightedIndex\", \"inputValue\", \"isOpen\", \"selectedItem\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, forwardRef, useState, useEffect, useCallback } from 'react';\nimport VirtualList from '@segment/react-tiny-virtual-list';\nimport Downshift from 'downshift';\nimport fuzzaldrin from 'fuzzaldrin-plus';\nimport PropTypes from 'prop-types';\nimport { Position } from '../../constants';\nimport { Pane } from '../../layers';\nimport { Popover } from '../../popover';\nimport { Text } from '../../typography';\nimport AutocompleteItem from './AutocompleteItem';\n\nvar fuzzyFilter = function fuzzyFilter(itemToString) {\n  if (itemToString) {\n    return function (items, input) {\n      var wrappedItems = items.map(function (item) {\n        return {\n          key: itemToString(item),\n          item: item\n        };\n      });\n      return fuzzaldrin.filter(wrappedItems, input, {\n        key: 'key'\n      }).map(function (_ref) {\n        var item = _ref.item;\n        return item;\n      });\n    };\n  }\n\n  return function (items, input) {\n    return fuzzaldrin.filter(items, input);\n  };\n};\n\nvar noop = function noop() {};\n\nvar autocompleteItemRenderer = function autocompleteItemRenderer(props) {\n  return /*#__PURE__*/React.createElement(AutocompleteItem, props);\n};\n\nautocompleteItemRenderer.displayName = \"autocompleteItemRenderer\";\n/* eslint-disable react/prop-types */\n\nvar AutocompleteItems = function AutocompleteItems(_ref2) {\n  var getItemProps = _ref2.getItemProps,\n      getMenuProps = _ref2.getMenuProps,\n      highlightedIndex = _ref2.highlightedIndex,\n      inputValue = _ref2.inputValue,\n      isFilterDisabled = _ref2.isFilterDisabled,\n      itemSize = _ref2.itemSize,\n      itemToString = _ref2.itemToString,\n      itemsFilter = _ref2.itemsFilter,\n      originalItems = _ref2.originalItems,\n      popoverMaxHeight = _ref2.popoverMaxHeight,\n      _renderItem = _ref2.renderItem,\n      selectedItem = _ref2.selectedItem,\n      title = _ref2.title,\n      width = _ref2.width;\n  itemsFilter = itemsFilter || fuzzyFilter(itemToString);\n  var items = isFilterDisabled || inputValue.trim() === '' ? originalItems : itemsFilter(originalItems, inputValue);\n  if (items.length === 0) return null; // Pass the actual DOM ref to downshift, this fixes touch support\n\n  var menuProps = getMenuProps();\n  return /*#__PURE__*/React.createElement(Pane, _extends({\n    width: width\n  }, menuProps), title && /*#__PURE__*/React.createElement(Pane, {\n    padding: 8,\n    borderBottom: \"muted\"\n  }, /*#__PURE__*/React.createElement(Text, {\n    size: 300,\n    textTransform: \"uppercase\"\n  }, title)), items.length > 0 && /*#__PURE__*/React.createElement(VirtualList, {\n    width: \"100%\",\n    height: Math.min(items.length * itemSize, popoverMaxHeight),\n    itemSize: itemSize,\n    itemCount: items.length,\n    scrollToIndex: highlightedIndex || 0,\n    overscanCount: 3,\n    scrollToAlignment: \"auto\",\n    renderItem: function renderItem(_ref3) {\n      var index = _ref3.index,\n          style = _ref3.style;\n      var item = items[index];\n      var itemString = itemToString(item);\n      return _renderItem(getItemProps({\n        item: item,\n        key: itemString,\n        index: index,\n        style: style,\n        children: itemString,\n        isSelected: itemToString(selectedItem) === itemString,\n        isHighlighted: highlightedIndex === index\n      }));\n    }\n  }));\n};\n\nAutocompleteItems.displayName = \"AutocompleteItems\";\n/* eslint-enable react/prop-types */\n\nvar containerStyle = {\n  width: '100%'\n};\nvar Autocomplete = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function Autocomplete(props, ref) {\n  var children = props.children,\n      _props$itemSize = props.itemSize,\n      itemSize = _props$itemSize === void 0 ? 32 : _props$itemSize,\n      position = props.position,\n      _props$renderItem = props.renderItem,\n      renderItem = _props$renderItem === void 0 ? autocompleteItemRenderer : _props$renderItem,\n      _props$isFilterDisabl = props.isFilterDisabled,\n      isFilterDisabled = _props$isFilterDisabl === void 0 ? false : _props$isFilterDisabl,\n      itemsFilter = props.itemsFilter,\n      _props$itemToString = props.itemToString,\n      itemToString = _props$itemToString === void 0 ? function (i) {\n    return i ? String(i) : '';\n  } : _props$itemToString,\n      _props$popoverMaxHeig = props.popoverMaxHeight,\n      popoverMaxHeight = _props$popoverMaxHeig === void 0 ? 240 : _props$popoverMaxHeig,\n      _props$popoverMinWidt = props.popoverMinWidth,\n      popoverMinWidth = _props$popoverMinWidt === void 0 ? 240 : _props$popoverMinWidt,\n      allowOtherValues = props.allowOtherValues,\n      restProps = _objectWithoutProperties(props, _excluded);\n\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      targetWidth = _useState2[0],\n      setTargetWidth = _useState2[1];\n\n  var _useState3 = useState(),\n      _useState4 = _slicedToArray(_useState3, 2),\n      targetRef = _useState4[0],\n      setTargetRef = _useState4[1];\n\n  useEffect(function () {\n    var boundingWidth = targetRef === null || targetRef === void 0 ? void 0 : targetRef.getBoundingClientRect().width;\n    setTargetWidth(boundingWidth);\n  }, [targetRef, setTargetWidth, props.items.length, props.id]);\n  var stateReducer = useCallback(function (state, changes) {\n    if (Object.prototype.hasOwnProperty.call(changes, 'isOpen') && changes.isOpen) {\n      return _objectSpread(_objectSpread({}, changes), {}, {\n        highlightedIndex: props.items.indexOf(state.selectedItem)\n      });\n    }\n\n    if (props.allowOtherValues && state.isOpen && !changes.isOpen) {\n      return _objectSpread(_objectSpread({}, changes), {}, {\n        selectedItem: changes.selectedItem || state.inputValue,\n        inputValue: state.inputValue\n      });\n    }\n\n    return changes;\n  }, [props.items, props.allowOtherValues]);\n  return /*#__PURE__*/React.createElement(Downshift, _extends({\n    stateReducer: stateReducer,\n    scrollIntoView: noop,\n    itemToString: itemToString,\n    ref: ref\n  }, restProps), function (_ref4) {\n    var getItemProps = _ref4.getItemProps,\n        getMenuProps = _ref4.getMenuProps,\n        getRootProps = _ref4.getRootProps,\n        highlightedIndex = _ref4.highlightedIndex,\n        inputValue = _ref4.inputValue,\n        isShown = _ref4.isOpen,\n        selectedItem = _ref4.selectedItem,\n        restDownshiftProps = _objectWithoutProperties(_ref4, _excluded2);\n\n    return /*#__PURE__*/React.createElement(\"div\", {\n      style: containerStyle\n    }, /*#__PURE__*/React.createElement(Popover, {\n      bringFocusInside: false,\n      isShown: isShown,\n      minWidth: popoverMinWidth,\n      position: position || (targetWidth < popoverMinWidth ? Position.BOTTOM_LEFT : Position.BOTTOM),\n      content: /*#__PURE__*/React.createElement(AutocompleteItems, {\n        getItemProps: getItemProps,\n        getMenuProps: getMenuProps,\n        highlightedIndex: highlightedIndex,\n        inputValue: inputValue,\n        isFilterDisabled: isFilterDisabled,\n        itemsFilter: itemsFilter,\n        itemSize: itemSize,\n        itemToString: itemToString,\n        originalItems: props.items,\n        popoverMaxHeight: popoverMaxHeight,\n        renderItem: renderItem,\n        selectedItem: selectedItem,\n        title: props.title,\n        width: Math.max(targetWidth, popoverMinWidth)\n      }),\n      minHeight: 0,\n      animationDuration: 0\n    }, function (_ref5) {\n      var _getRef = _ref5.getRef,\n          isShownPopover = _ref5.isShown,\n          toggle = _ref5.toggle;\n      return children(_objectSpread({\n        isShown: isShownPopover,\n        toggle: toggle,\n        getRef: function getRef(ref) {\n          // Use the ref internally to determine the width\n          setTargetRef(ref);\n\n          _getRef(ref);\n        },\n        inputValue: inputValue,\n        selectedItem: selectedItem,\n        highlightedIndex: highlightedIndex\n      }, restDownshiftProps));\n    }));\n  });\n}));\nAutocomplete.propTypes = _objectSpread({\n  /**\n   * This prop can be either a string or a Node.\n   * It will provide a title for the items\n   */\n  title: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),\n\n  /**\n   * An array of items to be used as options for the select\n   */\n  items: PropTypes.array.isRequired,\n\n  /**\n   * The selected Item to be shown on the autocomplete\n   */\n  selectedItem: PropTypes.any,\n\n  /**\n   * In case the array of items is not an array of strings,\n   * this function is used on each item to return the string that will be shown on the filter\n   */\n  itemToString: PropTypes.func,\n\n  /**\n   * Function that will render the 'filter' component.\n   */\n  children: PropTypes.func.isRequired,\n\n  /**\n   * The height of each item in the list\n   * Because the list is virtualized this is required beforehand.\n   */\n  itemSize: PropTypes.number,\n\n  /**\n   * Function that returns a component to render the item\n   */\n  renderItem: PropTypes.func,\n\n  /**\n   * The position of the Popover the Autocomplete is rendered in.\n   */\n  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]),\n\n  /**\n   * A function that is used to filter the items.\n   * It should return a subset of the initial items.\n   * By default the \"fuzzaldrin-plus\" package is used.\n   */\n  itemsFilter: PropTypes.func,\n\n  /**\n   * Prop that enables and disables filtering\n   * True: Enables Filtering\n   * False: Disables Filtering\n   */\n  isFilterDisabled: PropTypes.bool,\n\n  /**\n   * Defines the minimum height the results container will be\n   */\n  popoverMinWidth: PropTypes.number,\n\n  /**\n   * Defines the maximum height the results container will be\n   */\n  popoverMaxHeight: PropTypes.number,\n\n  /**\n   * Whether or not the input accepts arbitrary user input beyond the provided items\n   */\n  allowOtherValues: PropTypes.bool\n}, Downshift.propTypes);\nexport default Autocomplete;","map":null,"metadata":{},"sourceType":"module"}