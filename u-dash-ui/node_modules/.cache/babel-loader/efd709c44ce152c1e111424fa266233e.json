{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"autocompleteProps\", \"buttonProps\", \"height\", \"initialSelectedItem\", \"inputProps\", \"isLoading\", \"itemToString\", \"items\", \"onChange\", \"openOnFocus\", \"placeholder\", \"selectedItem\", \"size\", \"width\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useState, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { dimensions, spacing, position, layout } from 'ui-box';\nimport { Autocomplete } from '../../autocomplete';\nimport { IconButton } from '../../buttons';\nimport { Group } from '../../group';\nimport { CaretDownIcon } from '../../icons';\nimport { TextInput } from '../../text-input';\nvar Combobox = /*#__PURE__*/memo(function Combobox(props) {\n  var autocompleteProps = props.autocompleteProps,\n      buttonProps = props.buttonProps,\n      height = props.height,\n      initialSelectedItem = props.initialSelectedItem,\n      inputProps = props.inputProps,\n      _props$isLoading = props.isLoading,\n      isLoading = _props$isLoading === void 0 ? false : _props$isLoading,\n      itemToString = props.itemToString,\n      items = props.items,\n      onChange = props.onChange,\n      _props$openOnFocus = props.openOnFocus,\n      openOnFocus = _props$openOnFocus === void 0 ? false : _props$openOnFocus,\n      placeholder = props.placeholder,\n      selectedItem = props.selectedItem,\n      _props$size = props.size,\n      size = _props$size === void 0 ? 'medium' : _props$size,\n      _props$width = props.width,\n      width = _props$width === void 0 ? 240 : _props$width,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var disabled = props.disabled || isLoading;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isOpenedByButton = _useState2[0],\n      setIsOpenedByButton = _useState2[1];\n\n  var handleStateChange = useCallback(function (changes, stateAndHelpers) {\n    if (Object.prototype.hasOwnProperty.call(changes, 'isOpen')) {\n      if (!changes.isOpen) {\n        setIsOpenedByButton(false);\n      }\n    }\n\n    if (autocompleteProps && typeof autocompleteProps.onStateChange === 'function') {\n      autocompleteProps.onStateChange(changes, stateAndHelpers);\n    }\n  }, [autocompleteProps]);\n  return /*#__PURE__*/React.createElement(Autocomplete, _extends({\n    items: items,\n    selectedItem: selectedItem,\n    initialSelectedItem: initialSelectedItem,\n    itemToString: itemToString,\n    onChange: onChange,\n    isFilterDisabled: isOpenedByButton\n  }, autocompleteProps, {\n    onStateChange: handleStateChange\n  }), function (_ref) {\n    var clearSelection = _ref.clearSelection,\n        getInputProps = _ref.getInputProps,\n        getRef = _ref.getRef,\n        getToggleButtonProps = _ref.getToggleButtonProps,\n        inputValue = _ref.inputValue,\n        isShown = _ref.isShown,\n        openMenu = _ref.openMenu;\n    return /*#__PURE__*/React.createElement(Group, _extends({\n      ref: getRef,\n      size: size,\n      width: width\n    }, rest), /*#__PURE__*/React.createElement(TextInput, _extends({\n      width: 0,\n      flex: 1,\n      height: height,\n      value: inputValue,\n      borderTopRightRadius: 0,\n      borderBottomRightRadius: 0,\n      disabled: disabled\n    }, getInputProps(_objectSpread(_objectSpread({}, inputProps), {}, {\n      placeholder: placeholder,\n      onFocus: function onFocus() {\n        if (openOnFocus) openMenu();\n      },\n      onChange: function onChange(e) {\n        if (isOpenedByButton) {\n          setIsOpenedByButton(false);\n        }\n\n        if (e.target.value.trim() === '') {\n          // Prevent the selected item from sticking around\n          clearSelection();\n        }\n      }\n    })))), /*#__PURE__*/React.createElement(IconButton, _extends({\n      color: \"muted\",\n      icon: isLoading ? undefined : CaretDownIcon,\n      appearance: \"default\",\n      height: height,\n      marginTop: 0,\n      marginBottom: 0,\n      marginLeft: -1,\n      paddingLeft: isLoading ? 12 : 0,\n      paddingRight: 0,\n      borderTopLeftRadius: 0,\n      borderBottomLeftRadius: 0,\n      disabled: disabled,\n      isLoading: isLoading\n    }, getToggleButtonProps(_objectSpread(_objectSpread({}, buttonProps), {}, {\n      onClick: function onClick() {\n        if (!isShown) {\n          setIsOpenedByButton(true);\n        }\n      }\n    })))));\n  });\n});\nCombobox.propTypes = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, dimensions.propTypes), spacing.propTypes), position.propTypes), layout.propTypes), {}, {\n  /**\n   * The options to show in the menu.\n   */\n  items: PropTypes.array.isRequired,\n\n  /**\n   * The selected item when controlled.\n   */\n  selectedItem: PropTypes.any,\n\n  /**\n   * Function called when value changes.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * When true, open the autocomplete on focus.\n   */\n  openOnFocus: PropTypes.bool,\n\n  /**\n   * Default selected item when uncontrolled.\n   */\n  initialSelectedItem: PropTypes.any,\n\n  /**\n   * The placeholder text when there is no value present.\n   */\n  placeholder: PropTypes.string,\n\n  /**\n   * In case the array of items is not an array of strings,\n   * this function is used on each item to return the string that will be shown on the filter\n   */\n  itemToString: PropTypes.func,\n\n  /**\n   * Properties forwarded to the input. Use with caution.\n   */\n  inputProps: PropTypes.object,\n\n  /**\n   * Properties forwarded to the button. Use with caution.\n   */\n  buttonProps: PropTypes.object,\n\n  /**\n   * Properties forwarded to the autocomplete component. Use with caution.\n   */\n  autocompleteProps: PropTypes.object,\n\n  /**\n   * Makes the input element disabled.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * When true, show a loading spinner. This also disables the button.\n   */\n  isLoading: PropTypes.bool,\n  size: PropTypes.oneOf(['small', 'medium', 'large'])\n});\nexport default Combobox;","map":null,"metadata":{},"sourceType":"module"}