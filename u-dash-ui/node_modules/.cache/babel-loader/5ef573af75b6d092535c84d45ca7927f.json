{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"acceptedMimeTypes\", \"description\", \"disabled\", \"hint\", \"isRequired\", \"label\", \"labelFor\", \"maxFiles\", \"maxSizeInBytes\", \"onAccepted\", \"onChange\", \"onRejected\", \"onRemove\", \"renderFile\", \"validationMessage\", \"values\"],\n    _excluded2 = [\"className\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, forwardRef, useState, useRef, useCallback } from 'react';\nimport isEmpty from 'lodash.isempty';\nimport PropTypes from 'prop-types';\nimport Box from 'ui-box';\nimport { Key } from '../../constants';\nimport { FormField } from '../../form-field';\nimport { useStyleConfig } from '../../hooks';\nimport { UploadIcon } from '../../icons';\nimport arrayToCsv from '../../lib/array-to-csv';\nimport isFunction from '../../lib/is-function';\nimport safeInvoke from '../../lib/safe-invoke';\nimport { majorScale } from '../../scales';\nimport { useTheme } from '../../theme';\nimport { Text, Paragraph } from '../../typography';\nimport FileCard from './FileCard';\nimport getFileDataTransferItems from './utils/get-file-data-transfer-items';\nimport { getMaxFilesMessage } from './utils/messages';\nimport splitFiles from './utils/split-files';\nvar UploaderState = {\n  Initial: 'initial',\n  Dragging: 'dragging',\n  Error: 'error'\n};\nvar disabledPseudoSelector = \"&[aria-disabled='true']\";\nvar dragHoverPseudoSelector = \"&[data-state='\".concat(UploaderState.Dragging, \"']\");\nvar invalidPseudoSelector = \"&[aria-invalid='true']\";\nvar hoverPseudoSelector = \"&:hover:not(\".concat(disabledPseudoSelector, \"):not(\").concat(dragHoverPseudoSelector, \"):not(\").concat(invalidPseudoSelector, \")\");\nvar styleModifiers = {};\nvar pseudoSelectors = {\n  _focus: '&:focus',\n  _hover: hoverPseudoSelector,\n  _hoverBrowseCopy: \"\".concat(hoverPseudoSelector, \" span:first-of-type\"),\n  _hoverOrDragCopy: \"\".concat(hoverPseudoSelector, \" span:last-of-type\"),\n  _dragHover: dragHoverPseudoSelector,\n  _disabled: disabledPseudoSelector,\n  _invalid: invalidPseudoSelector\n};\nvar internalStyles = {};\nvar FileUploader = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function (props, ref) {\n  var acceptedMimeTypes = props.acceptedMimeTypes,\n      description = props.description,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled,\n      hint = props.hint,\n      isRequired = props.isRequired,\n      label = props.label,\n      labelFor = props.labelFor,\n      maxFiles = props.maxFiles,\n      maxSizeInBytes = props.maxSizeInBytes,\n      onAccepted = props.onAccepted,\n      onChange = props.onChange,\n      onRejected = props.onRejected,\n      onRemove = props.onRemove,\n      renderFile = props.renderFile,\n      validationMessageProp = props.validationMessage,\n      values = props.values,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var _useTheme = useTheme(),\n      colors = _useTheme.colors;\n\n  var _useStyleConfig = useStyleConfig('FileUploader', styleModifiers, pseudoSelectors, internalStyles),\n      className = _useStyleConfig.className,\n      boxProps = _objectWithoutProperties(_useStyleConfig, _excluded2);\n\n  var _useState = useState(UploaderState.Initial),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  var _useState3 = useState(''),\n      _useState4 = _slicedToArray(_useState3, 2),\n      validationMessage = _useState4[0],\n      setValidationMessage = _useState4[1];\n  /**\n   * The underlying <input type=\"file\" /> DOM element won't accept the same file after it has been\n   * picked unless it is rerendered manually - if a user selects and removes a file, they should\n   * still be able to pick it again without refreshing the page.\n   * https://stackoverflow.com/a/45846251\n   */\n\n\n  var _useState5 = useState(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      fileInputKey = _useState6[0],\n      setFileInputKey = _useState6[1];\n\n  var fileInputRef = useRef(null);\n  var orDragCopy = \"or drag \".concat(maxFiles === 1 ? 'a file' : 'files', \" here\"); // If the dropzone is meant to be a single file input and we already have a file, don't render\n  // the dropzone which will always result in rejected files/errors.\n\n  var renderDropzone = maxFiles !== 1 || isEmpty(values);\n  var resetState = useCallback(function () {\n    setState(UploaderState.Initial);\n    setValidationMessage('');\n  }, []);\n  var handleChange = useCallback(\n  /**\n   * @param {FileList} fileList\n   */\n  function (fileList) {\n    setFileInputKey(function (prev) {\n      return prev + 1;\n    });\n\n    if (isEmpty(fileList)) {\n      safeInvoke(onChange, []);\n      return;\n    }\n\n    var files = _toConsumableArray(fileList);\n\n    safeInvoke(onChange, files);\n\n    var _splitFiles = splitFiles(files, {\n      maxSizeInBytes: maxSizeInBytes,\n      acceptedMimeTypes: acceptedMimeTypes,\n      currentFileCount: values === null || values === void 0 ? void 0 : values.length,\n      maxFiles: maxFiles\n    }),\n        accepted = _splitFiles.accepted,\n        rejected = _splitFiles.rejected;\n\n    if (!isEmpty(accepted)) {\n      safeInvoke(onAccepted, accepted);\n    }\n\n    if (!isEmpty(rejected)) {\n      safeInvoke(onRejected, rejected);\n    }\n  }, [acceptedMimeTypes, maxFiles, maxSizeInBytes, onAccepted, onChange, onRejected, values === null || values === void 0 ? void 0 : values.length]);\n  var handleClick = useCallback(function () {\n    if (disabled) {\n      return;\n    }\n\n    if (fileInputRef.current == null) {\n      return;\n    }\n\n    fileInputRef.current.click();\n  }, [disabled]);\n  var handleDragOver = useCallback(\n  /**\n   * @param {React.DragEvent<HTMLDivElement>} event\n   */\n  function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    event.dataTransfer.dropEffect = 'copy';\n\n    if (disabled) {\n      return;\n    }\n\n    var dragItems = getFileDataTransferItems(event.dataTransfer.items);\n    var draggingCount = dragItems.length;\n\n    var _ref = values !== null && values !== void 0 ? values : [],\n        currentCount = _ref.length;\n\n    if (maxFiles == null || maxFiles < 0) {\n      setState(UploaderState.Dragging);\n      return;\n    }\n\n    if (draggingCount > maxFiles || draggingCount + currentCount > maxFiles) {\n      setValidationMessage(getMaxFilesMessage(maxFiles));\n      setState(UploaderState.Error);\n      return;\n    }\n\n    setState(UploaderState.Dragging);\n  }, [disabled, maxFiles, values]);\n  var handleDragLeave = useCallback(function () {\n    return resetState();\n  }, [resetState]);\n  var handleDrop = useCallback(\n  /**\n   * @param {React.DragEvent<HTMLDivElement>} event\n   */\n  function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (disabled) {\n      return;\n    }\n\n    resetState();\n    handleChange(event.dataTransfer.files);\n  }, [disabled, handleChange, resetState]);\n  var handleInputChange = useCallback(\n  /**\n   * @param {React.ChangeEvent<HTMLInputElement>} event\n   */\n  function (event) {\n    // Theoretically the input should not be accessible at all when disabled,\n    // but this should act as a safeguard\n    if (disabled) {\n      return;\n    }\n\n    handleChange(event.target.files);\n  }, [disabled, handleChange]);\n  var handleKeyDown = useCallback(\n  /**\n   * @param {React.KeyboardEvent<HTMLDivElement>} event\n   */\n  function (event) {\n    if (event.key !== Key.Enter && event.key !== Key.Space) {\n      return;\n    }\n\n    event.preventDefault();\n    handleClick();\n  }, [handleClick]);\n  return /*#__PURE__*/React.createElement(Box, {\n    ref: ref\n  }, /*#__PURE__*/React.createElement(FormField, {\n    label: label,\n    labelFor: labelFor,\n    description: description,\n    hint: hint,\n    isRequired: isRequired // Always override the validationMessage from prop if we have a message to display from dragging\n    ,\n    validationMessage: !isEmpty(validationMessage) ? /*#__PURE__*/React.createElement(Text, {\n      color: colors.red500\n    }, validationMessage) : validationMessageProp\n  }, renderDropzone && /*#__PURE__*/React.createElement(Box, _extends({\n    \"aria-disabled\": disabled,\n    \"aria-invalid\": state === UploaderState.Error,\n    className: className,\n    \"data-state\": state,\n    onClick: handleClick,\n    onDragLeave: handleDragLeave,\n    onDragOver: handleDragOver,\n    onDrop: handleDrop,\n    onKeyDown: handleKeyDown,\n    tabIndex: disabled ? undefined : 0\n  }, boxProps, rest), /*#__PURE__*/React.createElement(Box, {\n    accept: arrayToCsv(acceptedMimeTypes),\n    display: \"none\",\n    is: \"input\",\n    tabIndex: -1,\n    key: fileInputKey,\n    multiple: maxFiles !== 1,\n    onChange: handleInputChange,\n    ref: fileInputRef,\n    type: \"file\"\n  }), /*#__PURE__*/React.createElement(Box, {\n    alignItems: \"center\",\n    backgroundColor: disabled ? colors.gray90 : colors.gray200,\n    borderRadius: \"50%\",\n    display: \"flex\",\n    height: majorScale(7),\n    justifyContent: \"center\",\n    pointerEvents: \"none\",\n    width: majorScale(7)\n  }, /*#__PURE__*/React.createElement(UploadIcon, {\n    color: disabled ? colors.gray400 : colors.gray500,\n    size: majorScale(3)\n  })), /*#__PURE__*/React.createElement(Paragraph, {\n    marginTop: majorScale(3),\n    pointerEvents: \"none\"\n  }, /*#__PURE__*/React.createElement(Text, {\n    color: disabled ? colors.gray500 : colors.blue400\n  }, \"Browse \"), /*#__PURE__*/React.createElement(Text, {\n    color: disabled ? colors.gray500 : colors.gray700\n  }, orDragCopy)))), /*#__PURE__*/React.createElement(Box, {\n    marginTop: majorScale(2)\n  }, values === null || values === void 0 ? void 0 : values.map(\n  /**\n   * @param {File} file\n   * @param {number} index\n   */\n  function (file, index) {\n    return isFunction(renderFile) ? renderFile(file, index) : /*#__PURE__*/React.createElement(FileCard, {\n      key: \"\".concat(file.name, \"-\").concat(index),\n      name: file.name,\n      onRemove: isFunction(onRemove) ? function () {\n        return onRemove(file);\n      } : undefined,\n      sizeInBytes: file.size,\n      type: file.type\n    });\n  })));\n}));\nFileUploader.propTypes = _objectSpread(_objectSpread({}, FormField.propTypes), {}, {\n  /**\n   * MIME types (not file extensions) to accept\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types\n   */\n  acceptedMimeTypes: PropTypes.array,\n\n  /**\n   * When true, displays a disabled state where drops don't fire and the native browser picker doesn't open\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Maximum number of files to accept\n   */\n  maxFiles: PropTypes.number,\n\n  /**\n   * Maximum size of an **individual** file to accept\n   */\n  maxSizeInBytes: PropTypes.number,\n\n  /**\n   * Callback for when files are accepted via drop or the native browser picker\n   * @type {(files: File[]) => void}\n   */\n  onAccepted: PropTypes.func,\n\n  /**\n   * Callback for when files are added via drop or the native browser picker, which includes both\n   * the accepted and rejected files\n   * @type {(files: File[]) => void}\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * Callback for when files are rejected via drop or the native browser picker\n   * @type {(fileRejections: FileRejection[]) => void}\n   */\n  onRejected: PropTypes.func,\n\n  /**\n   * Callback to fire when a file should be removed\n   * @type {(file: File) => void}\n   */\n  onRemove: PropTypes.func,\n\n  /**\n   * Custom render function for displaying the file underneath the uploader\n   * @type {(file: File, index: number) => React.ReactNode}\n   */\n  renderFile: PropTypes.func,\n\n  /**\n   * File values to render underneath the uploader\n   * @type {File}\n   */\n  values: PropTypes.array\n});\nexport default FileUploader;","map":null,"metadata":{},"sourceType":"module"}