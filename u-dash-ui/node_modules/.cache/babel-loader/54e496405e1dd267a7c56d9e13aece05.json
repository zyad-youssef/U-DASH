{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"children\", \"size\", \"disabled\", \"placeholder\", \"isSelectable\", \"textProps\", \"autoFocus\", \"onChange\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { useLatest } from '../../hooks';\nimport safeInvoke from '../../lib/safe-invoke';\nimport { Portal } from '../../portal';\nimport { Stack } from '../../stack';\nimport EditableCellField from './EditableCellField';\nimport TableCell from './TableCell';\nimport TextTableCell from './TextTableCell';\nvar emptyProps = {};\nvar EditableCell = /*#__PURE__*/memo(function EditableCell(props) {\n  var children = props.children,\n      _props$size = props.size,\n      size = _props$size === void 0 ? 300 : _props$size,\n      disabled = props.disabled,\n      placeholder = props.placeholder,\n      _props$isSelectable = props.isSelectable,\n      isSelectable = _props$isSelectable === void 0 ? true : _props$isSelectable,\n      _props$textProps = props.textProps,\n      textProps = _props$textProps === void 0 ? emptyProps : _props$textProps,\n      _props$autoFocus = props.autoFocus,\n      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,\n      onChange = props.onChange,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var cursor = 'text';\n  var mainRef = useRef(null);\n\n  var _useState = useState(children),\n      _useState2 = _slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var _useState3 = useState(autoFocus),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isEditing = _useState4[0],\n      setIsEditing = _useState4[1];\n\n  var onChangeRef = useLatest(onChange);\n  useEffect(function () {\n    setValue(children);\n  }, [children]);\n  var handleDoubleClick = useCallback(function () {\n    if (disabled || !isSelectable) return;\n    setIsEditing(true);\n  }, [disabled, isSelectable]);\n  var handleKeyDown = useCallback(function (e) {\n    if (disabled) return;\n    var key = e.key;\n    /**\n     * When the user presses a character on the keyboard, use that character\n     * as the value in the text field.\n     */\n\n    if (key === 'Enter' || key === 'Shift') {\n      setIsEditing(true);\n    } else if (key.match(/^[a-z]{0,10}$/) && !e.metaKey && !e.ctrlKey && !e.altKey) {\n      setIsEditing(true);\n      setValue(function (prev) {\n        return prev + key;\n      });\n    }\n  }, [disabled]);\n  var handleFieldChangeComplete = useCallback(function (value) {\n    setIsEditing(false);\n    setValue(value);\n    safeInvoke(onChangeRef.current, value);\n\n    if (mainRef.current && isSelectable) {\n      mainRef.current.focus();\n    }\n  }, // onChangeRef is a ref\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [isSelectable]);\n  var handleFieldCancel = useCallback(function () {\n    setIsEditing(false);\n  }, []);\n  var handleClick = useCallback(function () {\n    if (mainRef.current) {\n      mainRef.current.focus();\n    }\n  }, []);\n  var getTargetRef = useCallback(function () {\n    return mainRef.current;\n  }, []);\n\n  if (disabled) {\n    cursor = 'not-allowed';\n  } else if (isSelectable) {\n    cursor = 'default';\n  }\n\n  var lessOpacity = useMemo(function () {\n    return disabled || !value && placeholder;\n  }, [disabled, value, placeholder]);\n  var mergedTextProps = useMemo(function () {\n    return _objectSpread({\n      size: size,\n      opacity: lessOpacity ? 0.5 : 1\n    }, textProps);\n  }, [lessOpacity, size, textProps]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TextTableCell, _extends({\n    ref: mainRef,\n    isSelectable: isSelectable,\n    onClick: handleClick,\n    onDoubleClick: handleDoubleClick,\n    onKeyDown: handleKeyDown,\n    cursor: cursor,\n    textProps: mergedTextProps\n  }, rest), value || placeholder), isEditing && /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(Stack, null, function (zIndex) {\n    return /*#__PURE__*/React.createElement(EditableCellField, {\n      zIndex: zIndex,\n      getTargetRef: getTargetRef,\n      value: value,\n      onEscape: handleFieldCancel,\n      onChangeComplete: handleFieldChangeComplete,\n      onCancel: handleFieldCancel,\n      size: size\n    });\n  })));\n});\nEditableCell.propTypes = _objectSpread(_objectSpread({}, TableCell.propTypes), {}, {\n  /*\n   * Makes the TableCell focusable.\n   * Will add tabIndex={-1 || this.props.tabIndex}.\n   */\n  isSelectable: PropTypes.bool,\n\n  /**\n   * When true, the cell can't be edited.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Optional placeholder when children is falsy.\n   */\n  placeholder: PropTypes.node,\n\n  /**\n   * The size used for the TextTableCell and Textarea.\n   */\n  size: PropTypes.oneOf([300, 400]),\n\n  /**\n   * This is the value of the cell.\n   */\n  children: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * Function called when value changes. (value: string) => void.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * When true, the cell will initialize in the editing state.\n   */\n  autoFocus: PropTypes.bool\n});\nexport default EditableCell;","map":null,"metadata":{},"sourceType":"module"}