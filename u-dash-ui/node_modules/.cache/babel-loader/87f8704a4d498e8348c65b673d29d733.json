{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"addOnBlur\", \"disabled\", \"height\", \"separator\", \"values\", \"tagSubmitKey\", \"tagProps\", \"onAdd\", \"onChange\", \"onRemove\", \"onBlur\", \"onFocus\", \"onInputChange\", \"className\", \"inputProps\", \"inputRef\", \"isInvalid\", \"autocompleteItems\"],\n    _excluded2 = [\"className\"],\n    _excluded3 = [\"onBlur\", \"onChange\", \"onKeyDown\"];\n/**\n * @overview TagInput accepts multiple values that can be individually removed\n */\n\nimport React, { memo, forwardRef, useState } from 'react';\nimport cx from 'classnames';\nimport omit from 'lodash.omit';\nimport PropTypes from 'prop-types';\nimport Box from 'ui-box';\nimport { Autocomplete } from '../../autocomplete';\nimport { Button } from '../../buttons';\nimport { useId, useStyleConfig } from '../../hooks';\nimport { CaretDownIcon } from '../../icons';\nimport safeInvoke from '../../lib/safe-invoke';\nimport { majorScale, minorScale } from '../../scales';\nimport { TextInput } from '../../text-input';\nimport Tag from './Tag';\nvar GET_KEY_FOR_TAG_DELIMITER = {\n  enter: 'Enter',\n  space: ' '\n};\nvar emptyProps = {};\nvar emptyArray = [];\nvar internalStyles = {\n  alignItems: 'center',\n  display: 'inline-flex',\n  flexWrap: 'wrap',\n  position: 'relative'\n};\nvar pseudoSelectors = {\n  _focused: '&[aria-activedescendant]',\n  _disabled: '&[aria-disabled=\"true\"]',\n  _invalid: '&[aria-invalid=\"true\"]:not(:focus)'\n};\nvar TagInput = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function TagInput(props, ref) {\n  var _props$addOnBlur = props.addOnBlur,\n      addOnBlur = _props$addOnBlur === void 0 ? false : _props$addOnBlur,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled,\n      _props$height = props.height,\n      height = _props$height === void 0 ? 32 : _props$height,\n      _props$separator = props.separator,\n      separator = _props$separator === void 0 ? /[,\\n\\r]/ : _props$separator,\n      _props$values = props.values,\n      values = _props$values === void 0 ? emptyArray : _props$values,\n      _props$tagSubmitKey = props.tagSubmitKey,\n      tagSubmitKey = _props$tagSubmitKey === void 0 ? 'enter' : _props$tagSubmitKey,\n      _props$tagProps = props.tagProps,\n      tagProps = _props$tagProps === void 0 ? emptyProps : _props$tagProps,\n      onAdd = props.onAdd,\n      onChange = props.onChange,\n      onRemove = props.onRemove,\n      onBlur = props.onBlur,\n      onFocus = props.onFocus,\n      onInputChange = props.onInputChange,\n      className = props.className,\n      _props$inputProps = props.inputProps,\n      inputProps = _props$inputProps === void 0 ? emptyProps : _props$inputProps,\n      inputRef = props.inputRef,\n      isInvalid = props.isInvalid,\n      autocompleteItems = props.autocompleteItems,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var _useState = useState(''),\n      _useState2 = _slicedToArray(_useState, 2),\n      inputValue = _useState2[0],\n      setInputValue = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isFocused = _useState4[0],\n      setIsFocused = _useState4[1];\n\n  var id = useId('TagInput');\n  var autocompleteId = \"TagInputAutocomplete-\".concat(values.length);\n  var inputId = inputProps && inputProps.id ? inputProps.id : id;\n  var hasAutocomplete = Array.isArray(autocompleteItems) && autocompleteItems.length > 0;\n\n  var getValues = function getValues() {\n    var inputValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    inputValue = inputValue || '';\n    return separator ? inputValue.split(separator).map(function (v) {\n      return v.trim();\n    }).filter(function (v) {\n      return v.length > 0;\n    }) : [inputValue];\n  };\n\n  var addTags = function addTags() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var newValues = getValues(value);\n    var shouldClearInput = safeInvoke(onAdd, newValues);\n\n    if (typeof onChange === 'function') {\n      shouldClearInput = shouldClearInput || onChange(values.concat(newValues));\n    }\n\n    if (shouldClearInput !== false) {\n      setInputValue('');\n    }\n  };\n\n  var removeTagAtIndex = function removeTagAtIndex(index) {\n    safeInvoke(onRemove, values[index], index); // Remove item at index as a new array\n\n    var newValues = values.filter(function (_, i) {\n      return i !== index;\n    });\n    safeInvoke(onChange, newValues);\n  };\n\n  var handleBackspaceToRemove = function handleBackspaceToRemove() {\n    removeTagAtIndex(values.length - 1);\n  };\n\n  var handleBlur = function handleBlur(event) {\n    var container = event.target;\n    requestAnimationFrame(function () {\n      if (!container.contains(document.activeElement)) {\n        if (addOnBlur && inputValue) {\n          addTags(inputValue);\n          setInputValue('');\n        }\n\n        setIsFocused(false);\n      }\n    });\n    safeInvoke(onBlur, event);\n  };\n\n  var handleInputChange = function handleInputChange(event) {\n    setInputValue(event.target.value);\n    safeInvoke(onInputChange, event);\n  };\n\n  var handleInputFocus = function handleInputFocus(event) {\n    setIsFocused(true);\n    safeInvoke(onFocus, event);\n  };\n\n  var handleKeyDown = function handleKeyDown(event) {\n    var _event$target = event.target,\n        selectionEnd = _event$target.selectionEnd,\n        value = _event$target.value;\n    var key = GET_KEY_FOR_TAG_DELIMITER[tagSubmitKey];\n\n    if (event.key === key) {\n      event.preventDefault();\n      addTags(value);\n    } else if (event.key === 'Backspace' && selectionEnd === 0) {\n      handleBackspaceToRemove(event);\n    }\n  };\n\n  var handleRemoveTag = function handleRemoveTag(event) {\n    // Using data attribute to simplify callback logic -- one handler for all children\n    var index = Number(event.currentTarget.parentElement.getAttribute('data-tag-index'));\n    removeTagAtIndex(index);\n  };\n\n  var maybeRenderTag = function maybeRenderTag(tag, index) {\n    if (!tag) {\n      return null;\n    }\n\n    var propsForElement = safeInvoke(tagProps, tag, index) || tagProps;\n    return /*#__PURE__*/React.createElement(Tag, _extends({\n      key: \"\".concat(tag, \":\").concat(index),\n      \"data-tag-index\": index,\n      marginX: majorScale(1),\n      marginY: minorScale(1) * 1.5,\n      onRemove: disabled ? null : handleRemoveTag,\n      isRemovable: !disabled\n    }, propsForElement), tag);\n  };\n\n  var _useStyleConfig = useStyleConfig('TagInput', {\n    appearance: 'default',\n    height: height\n  }, pseudoSelectors, internalStyles),\n      themedContainerClassName = _useStyleConfig.className,\n      boxProps = _objectWithoutProperties(_useStyleConfig, _excluded2);\n\n  return /*#__PURE__*/React.createElement(Box, _extends({\n    \"aria-disabled\": disabled || undefined,\n    \"aria-activedescendant\": isFocused ? inputId : undefined,\n    \"aria-invalid\": isInvalid,\n    className: cx(themedContainerClassName, className),\n    ref: ref,\n    onBlur: handleBlur\n  }, boxProps, rest, {\n    paddingRight: hasAutocomplete ? majorScale(3) : undefined\n  }), /*#__PURE__*/React.createElement(Box, {\n    flexGrow: \"1\",\n    display: \"inline-block\"\n  }, /*#__PURE__*/React.createElement(Autocomplete, {\n    onChange: function onChange(changedItem) {\n      addTags(changedItem);\n      setInputValue('');\n    },\n    items: hasAutocomplete ? autocompleteItems : [],\n    id: autocompleteId,\n    selectedItem: \"\",\n    inputValue: inputValue\n  }, function (autocompleteProps) {\n    var closeMenu = autocompleteProps.closeMenu,\n        getInputProps = autocompleteProps.getInputProps,\n        autocompleteGetRef = autocompleteProps.getRef,\n        getToggleButtonProps = autocompleteProps.getToggleButtonProps,\n        highlightedIndex = autocompleteProps.highlightedIndex;\n\n    var _getInputProps = getInputProps(),\n        autocompleteOnBlur = _getInputProps.onBlur,\n        autocompleteOnChange = _getInputProps.onChange,\n        autocompleteKeyDown = _getInputProps.onKeyDown,\n        autocompleteRestProps = _objectWithoutProperties(_getInputProps, _excluded3);\n\n    var handleAutocompleteKeydown = function handleAutocompleteKeydown(e) {\n      autocompleteKeyDown(e);\n\n      if (e.key === 'Backspace' || !(highlightedIndex > -1)) {\n        handleKeyDown(e);\n\n        if (e.key === GET_KEY_FOR_TAG_DELIMITER[tagSubmitKey]) {\n          closeMenu();\n          setInputValue('');\n        }\n      }\n\n      if (e.key === 'Backspace' && e.target.selectionEnd === 0) {\n        closeMenu();\n      }\n    };\n\n    return /*#__PURE__*/React.createElement(Box, {\n      display: \"flex\",\n      ref: function ref(boxInputRef) {\n        autocompleteGetRef(boxInputRef);\n      },\n      flexWrap: \"wrap\",\n      width: inputProps.width\n    }, values.map(maybeRenderTag), /*#__PURE__*/React.createElement(TextInput, _extends({\n      appearance: \"none\",\n      disabled: disabled,\n      height: height - 4,\n      flexGrow: \"1\",\n      type: \"text\"\n    }, omit(inputProps, ['width']), autocompleteRestProps, {\n      value: inputValue,\n      id: inputId,\n      ref: function ref(textInputRef) {\n        if (inputRef instanceof Function) {\n          inputRef(textInputRef);\n        } else if (inputRef) {\n          inputRef.current = textInputRef;\n        }\n      },\n      onBlur: function onBlur(e) {\n        autocompleteOnBlur(e);\n        safeInvoke(inputProps.onBlur, e);\n      },\n      onFocus: function onFocus(e) {\n        handleInputFocus(e);\n        safeInvoke(inputProps.onFocus, e);\n      },\n      onChange: function onChange(e) {\n        handleInputChange(e);\n        autocompleteOnChange(e);\n      },\n      onKeyDown: handleAutocompleteKeydown\n    })), hasAutocomplete && /*#__PURE__*/React.createElement(Button, _extends({\n      appearance: \"none\",\n      background: \"gray100\",\n      position: \"absolute\",\n      top: minorScale(1) * 1.5,\n      right: minorScale(1),\n      height: minorScale(5),\n      padding: 0,\n      width: minorScale(5),\n      minWidth: minorScale(5),\n      display: \"flex\",\n      alignItems: \"center\",\n      justifyContent: \"center\",\n      borderRadius: minorScale(1),\n      cursor: disabled ? undefined : 'pointer',\n      \"data-testid\": \"TagInput-autocomplete-toggle\"\n    }, getToggleButtonProps()), /*#__PURE__*/React.createElement(CaretDownIcon, {\n      color: \"muted\"\n    })));\n  })));\n}));\nTagInput.propTypes = {\n  /** Whether or not the inputValue should be added to the tags when the input blurs. */\n  addOnBlur: PropTypes.bool,\n\n  /** Autocomplete options to show when typing in a new value */\n  autocompleteItems: PropTypes.array,\n\n  /** The class name to apply to the container component. */\n  className: PropTypes.string,\n\n  /** Whether or not the input should be disabled. */\n  disabled: PropTypes.bool,\n\n  /** Whether or not the input is invalid. */\n  isInvalid: PropTypes.bool,\n\n  /** The vertical size of the input */\n  height: PropTypes.number,\n\n  /** Props to pass to the input component. Note that `ref` and `key` are not supported. See `inputRef`. */\n  inputProps: PropTypes.object,\n\n  /**\n   * Ref handler for the input element.\n   * (input: HTMLInputElement | null) => void\n   */\n  inputRef: PropTypes.func,\n\n  /**\n   * Callback invoked when new tags are added.\n   * Returning `false` will prevent clearing the input.\n   * (values: Array) => void | false\n   */\n  onAdd: PropTypes.func,\n\n  /**\n   * Callback invoked when focus on the input blurs.\n   * (event) => void\n   */\n  onBlur: PropTypes.func,\n\n  /**\n   * Callback invoked when the tag values change.\n   * Returning `false` will prevent clearing the input.\n   * (values: Array) => void | false\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * Callback invoked when the input receives focus.\n   * (event) => void\n   */\n  onFocus: PropTypes.func,\n\n  /**\n   * Callback invoked when the value of the input is changed. Shorthand for `inputProps={{ onChange }}`.\n   * (event) => void\n   */\n  onInputChange: PropTypes.func,\n\n  /**\n   * Callback invoked when a tag is removed.\n   * Receives value and index of removed tag.\n   * (value: string | node, index: number) => void\n   */\n  onRemove: PropTypes.func,\n\n  /** Value or RegExp to split on pasted text or on enter keypress */\n  separator: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp), PropTypes.oneOf([false])]),\n\n  /** Provide props to tag component (actually `Badge`, for now). */\n  tagProps: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n\n  /** Key to press in order to submit a new tag while typing.  */\n  tagSubmitKey: PropTypes.oneOf(['enter', 'space']),\n\n  /** Controlled tag values. Each value is rendered inside a tag. */\n  values: PropTypes.arrayOf(PropTypes.node)\n};\nexport default TagInput;","map":null,"metadata":{},"sourceType":"module"}