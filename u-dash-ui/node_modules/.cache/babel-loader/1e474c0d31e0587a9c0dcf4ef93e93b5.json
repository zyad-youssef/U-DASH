{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar _excluded = [\"getTargetRef\", \"isShown\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useState, useEffect, useRef } from 'react';\nimport cx from 'classnames';\nimport { css as glamorCss } from 'glamor';\nimport debounce from 'lodash.debounce';\nimport PropTypes from 'prop-types';\nimport { Position } from '../../constants';\nimport { useId } from '../../hooks';\nimport { Positioner } from '../../positioner';\nimport TooltipStateless from './TooltipStateless';\nvar emptyProps = {};\nvar Tooltip = /*#__PURE__*/memo(function Tooltip(props) {\n  var _props$appearance = props.appearance,\n      appearance = _props$appearance === void 0 ? 'default' : _props$appearance,\n      _props$position = props.position,\n      position = _props$position === void 0 ? Position.BOTTOM : _props$position,\n      content = props.content,\n      _props$hideDelay = props.hideDelay,\n      hideDelay = _props$hideDelay === void 0 ? 120 : _props$hideDelay,\n      _props$showDelay = props.showDelay,\n      showDelay = _props$showDelay === void 0 ? 0 : _props$showDelay,\n      propIsShown = props.isShown,\n      children = props.children,\n      _props$statelessProps = props.statelessProps,\n      statelessProps = _props$statelessProps === void 0 ? emptyProps : _props$statelessProps;\n  var id = useId('evergreen-tooltip');\n\n  var _useState = useState(propIsShown || false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isShown = _useState2[0],\n      setIsShown = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isShownByTarget = _useState4[0],\n      setIsShownByTarget = _useState4[1];\n\n  var closeTimer = useRef(undefined);\n\n  var mouseLeftTarget = function mouseLeftTarget() {\n    setIsShownByTarget(false);\n  };\n\n  var handleMouseLeaveTarget = debounce(mouseLeftTarget, hideDelay);\n\n  var hide = function hide() {\n    setIsShown(false); // Clean up any timeouts that may have been triggered from `showDelay`\n\n    clearTimeout(closeTimer.current);\n  };\n\n  var handleHide = debounce(hide, hideDelay); // Component will unmount\n\n  useEffect(function () {\n    return function () {\n      clearTimeout(closeTimer.current);\n    };\n  }, []);\n\n  var show = function show() {\n    if (isShown) return;\n\n    if (!showDelay) {\n      setIsShown(true);\n      return;\n    }\n\n    clearTimeout(closeTimer.current);\n    closeTimer.current = setTimeout(function () {\n      setIsShown(true);\n    }, showDelay);\n  };\n\n  var renderTarget = function renderTarget(_ref) {\n    var getRef = _ref.getRef;\n    var tooltipTargetProps = {\n      onMouseEnter: show,\n      onMouseLeave: handleHide,\n      'aria-describedby': id\n    };\n    /**\n     * Tooltips can be used within a Popover (not the other way around)\n     * When a Tooltip is used within a Popover, the Popover passes\n     * its props to the Tooltip in a `popoverProps` object.\n     */\n    // eslint-disable-next-line react/prop-types\n\n    if (props.popoverProps) {\n      var _props$popoverProps = props.popoverProps,\n          getTargetRef = _props$popoverProps.getTargetRef,\n          _isShown = _props$popoverProps.isShown,\n          popoverTargetProps = _objectWithoutProperties(_props$popoverProps, _excluded);\n\n      return /*#__PURE__*/React.cloneElement(children, _objectSpread(_objectSpread(_objectSpread({}, popoverTargetProps), tooltipTargetProps), {}, {\n        ref: function ref(_ref2) {\n          // Get the ref for the Tooltip.\n          getRef(_ref2); // Pass the ref to the Popover.\n\n          getTargetRef(_ref2);\n        }\n      }));\n    }\n    /**\n     * With normal usage only the props for a Tooltip are passed to the target.\n     */\n\n\n    return /*#__PURE__*/React.cloneElement(children, _objectSpread(_objectSpread({}, tooltipTargetProps), {}, {\n      ref: function ref(_ref3) {\n        getRef(_ref3);\n      }\n    }));\n  }; // eslint-disable-next-line react/prop-types\n\n\n  var isPopoverShown = function isPopoverShown() {\n    return props.popoverProps && props.popoverProps.isShown;\n  };\n\n  var handleMouseEnterTarget = function handleMouseEnterTarget() {\n    setIsShownByTarget(true);\n  };\n\n  var shown = (propIsShown || isShown || isShownByTarget) && !isPopoverShown(); // Tooltip was explicitly set to not be shown\n\n  if (propIsShown === false) {\n    shown = false;\n  }\n\n  return /*#__PURE__*/React.createElement(Positioner, {\n    target: renderTarget,\n    isShown: shown,\n    position: position,\n    animationDuration: 160\n  }, function (_ref4) {\n    var css = _ref4.css,\n        getRef = _ref4.getRef,\n        state = _ref4.state,\n        style = _ref4.style;\n    return /*#__PURE__*/React.createElement(TooltipStateless, _extends({\n      id: id,\n      appearance: appearance,\n      ref: getRef,\n      \"data-state\": state,\n      style: style,\n      onMouseEnter: handleMouseEnterTarget,\n      onMouseLeave: handleMouseLeaveTarget\n    }, statelessProps, {\n      className: cx(statelessProps.className, css ? glamorCss(css).toString() : undefined)\n    }), content);\n  });\n});\nTooltip.propTypes = {\n  /**\n   * The appearance of the tooltip.\n   */\n  appearance: PropTypes.oneOf(['default', 'card']),\n\n  /**\n   * The position the Popover is on.\n   */\n  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]),\n\n  /**\n   * The content of the Popover.\n   */\n  content: PropTypes.node,\n\n  /**\n   * Time in ms before hiding the Tooltip.\n   */\n  hideDelay: PropTypes.number,\n\n  /**\n   * Time in ms before showing the Tooltip.\n   */\n  showDelay: PropTypes.number,\n\n  /**\n   * When True, manually show the Tooltip.\n   */\n  isShown: PropTypes.bool,\n\n  /**\n   * The target button of the Tooltip.\n   */\n  children: PropTypes.node,\n\n  /**\n   * Properties passed through to the Tooltip.\n   */\n  statelessProps: PropTypes.object\n};\nexport default Tooltip;","map":null,"metadata":{},"sourceType":"module"}